<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#Git使用指南# 基本概念理解理解git的版本管理：使用git的每次提交，Git都会自动把它们串成一条时间线，这条时间线就是一个分支。如果没有新建分支，那么只有一条时间线，即只有一个分支，在Git里，这个分支叫主分支，即master分支。有一个HEAD指针指向当前分支（只有一个分支的情况下会指向master，而master是指向最新提交）。每个版本都会有自己的版本信息，如特有的版本号、版本名等。">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2020/10/21/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#Git使用指南# 基本概念理解理解git的版本管理：使用git的每次提交，Git都会自动把它们串成一条时间线，这条时间线就是一个分支。如果没有新建分支，那么只有一条时间线，即只有一个分支，在Git里，这个分支叫主分支，即master分支。有一个HEAD指针指向当前分支（只有一个分支的情况下会指向master，而master是指向最新提交）。每个版本都会有自己的版本信息，如特有的版本号、版本名等。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/25/d6tetP.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/25/d6tK1S.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/25/d6tup8.jpg">
<meta property="article:published_time" content="2020-10-21T01:16:18.098Z">
<meta property="article:modified_time" content="2020-10-21T01:15:29.809Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/08/25/d6tetP.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Git使用指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/21/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="article-date">
  <time datetime="2020-10-21T01:16:18.098Z" itemprop="datePublished">2020-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Git使用指南#</p>
<h2 id="基本概念理解"><a href="#基本概念理解" class="headerlink" title="基本概念理解"></a>基本概念理解</h2><p><em>理解git的版本管理：使用git的每次提交，Git都会自动把它们串成一条时间线，这条时间线就是一个分支。如果没有新建分支，那么只有一条时间线，即只有一个分支，在Git里，这个分支叫主分支，即master分支。有一个HEAD指针指向当前分支（只有一个分支的情况下会指向master，而master是指向最新提交）。每个版本都会有自己的版本信息，如特有的版本号、版本名等。</em></p>
<p><em>分支：在同一时间不同版本的存储库。默认情况下，版本库中有一个名为master的分支，也是默认的正在工作的分支。</em></p>
<p><em>HEAD是什么：一个特别指针，在git中它是一个指向你正在工作的本地分支的指针（可以把HEAD当作当前分支的别名），有了它，git就知道当前是在哪个分支上工作。如下图，假设HEAD正指向分支A：</em></p>
<p><img src="https://s1.ax1x.com/2020/08/25/d6tetP.png" alt="HEAD"></p>
<p><em>什么是commitID：一个SHA1 hash值，从暂存区提交(commit)代码到本地分支时会产生，相当于一次提交的标识，可用git log查看，使用时可用前7位代替完整的commitID。</em></p>
<h2 id="git常规开发流程"><a href="#git常规开发流程" class="headerlink" title="git常规开发流程"></a>git常规开发流程</h2><p><img src="https://s1.ax1x.com/2020/08/25/d6tK1S.png" alt="gitWorkFlow"><br><em>实际开发过程中，会基于master分支开很多的分支，乃至基于某分支新开分支；</em></p>
<p><em>有时push到远程仓库的代码有误或者其他原因需要进行回滚，具体操作后面会详述</em></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul>
<li><p>新建分支</p>
<ul>
<li>git branch feature1    </li>
</ul>
</li>
<li><p>切换分支</p>
<ul>
<li>git checkout feature1    </li>
</ul>
</li>
<li><p>新建并切换到新的分支</p>
<ul>
<li>git checkout -b feature1(实则为前两条命令的合并)    </li>
</ul>
</li>
<li><p>查看分支</p>
<ul>
<li>git branch -a  （所有分支）</li>
<li>git branch    (本地分支)  </li>
</ul>
</li>
<li><p>合并分支</p>
<ul>
<li>git merge feature1    </li>
</ul>
</li>
<li><p>删除分支</p>
<ul>
<li>git branch -d feature1  </li>
</ul>
</li>
</ul>
<h2 id="将远程主机的最新内容更新到本地"><a href="#将远程主机的最新内容更新到本地" class="headerlink" title="将远程主机的最新内容更新到本地"></a>将远程主机的最新内容更新到本地</h2><p><img src="https://s1.ax1x.com/2020/08/25/d6tup8.jpg" alt="pullOrfetch"></p>
<blockquote>
<p>可以简单的概括为：<br><strong>git fetch</strong>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否使用<strong>git merge</strong> 合并到本机分支中。<br>而<strong>git pull</strong> 则是将远程主机的最新内容拉下来后直接合并，即：<strong>git pull = git fetch + git merge</strong>，这样可能会产生冲突，需要手动解决。<br>下面我们来详细了解一下git fetch 和git pull 的用法：</p>
</blockquote>
<ul>
<li><p>git fetch(推荐使用)</p>
<ul>
<li><p>git fetch [远程主机名]    </p>
<blockquote>
<p>将某个远程主机（例如origin）的更新全部拉取到本地</p>
</blockquote>
</li>
<li><p>git fetch [远程主机名] [分支名]</p>
<blockquote>
<p>拉取某分支的更新到本地</p>
</blockquote>
<p>示例：</p>
<blockquote>
</blockquote>
<p>  git fetch origin master  //拉取origin主机的master分支的最新内容。此时会返回一个FETCH_HEAD,它指的是master分支在服务器上的最新状态<br>  git log -p FETCH_HEAD  //查看刚拉取的更新信息，通过信息来判断是否产生冲突<br>  git merge FETCH_HEAD  //如无冲突则执行此命令将拉取的内容合并到当前分支</p>
</li>
</ul>
</li>
<li><p>git pull</p>
<ul>
<li><p>git pull [远程主机名] [远程分支名]:[本地分支名]</p>
<blockquote>
<p>将远程主机的某个分支的更新取回，并与本地指定的分支合并(如果远程分支是与当前本地分支合并，可省略冒号及其后面部分)</p>
</blockquote>
<p>示例：</p>
<blockquote>
</blockquote>
<p>  git pull origin master  //将远程主机的master分支的更新取回，并与本地master分支合并。</p>
</li>
</ul>
</li>
</ul>
<h2 id="将本地分支推送到远程分支"><a href="#将本地分支推送到远程分支" class="headerlink" title="将本地分支推送到远程分支"></a>将本地分支推送到远程分支</h2><blockquote>
<p>git push的一般形式为git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt;;<br>例如 git push origin master :refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名，第一个master是本地分支名，第二个master是远程分支名</p>
</blockquote>
<ul>
<li><p>git push origin master </p>
<p>  如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</p>
</li>
<li><p>git push origin :refs/for/master </p>
<p>  如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master</p>
</li>
<li><p>git push origin</p>
<p>  如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 </p>
</li>
<li><p>git push</p>
<p>  如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名</p>
</li>
</ul>
<p><em>注意：refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads则不需要</em></p>
<h2 id="打标签（Tag）"><a href="#打标签（Tag）" class="headerlink" title="打标签（Tag）"></a>打标签（Tag）</h2><blockquote>
<p>通常在发布软件的时候打一个tag，tag会记录版本的commit号(如v1.0,v2.0等)，方便后期回溯</p>
</blockquote>
<blockquote>
<p>过程：</p>
</blockquote>
<pre><code>git add *
git commit -m &quot;v0.3&quot;
git tag v0.3
git push
git push origin v0.3</code></pre>
<ul>
<li><p>列出标签</p>
<ul>
<li>git tag (列出已有标签)</li>
<li>git tag -l “v1.5.*” （列出符合通配符规则的标签）</li>
</ul>
</li>
<li><p>创建标签</p>
<blockquote>
<p>Git 支持两种标签：<strong>轻量标签（lightweight）</strong>与<strong>附注标签（annotated）</strong>。</p>
</blockquote>
<blockquote>
<p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用,本质上是将提交校验和存储到一个文件中——没有保存任何其他信息</p>
</blockquote>
<blockquote>
<p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p>
</blockquote>
<ul>
<li><p>git tag -a [tagName] -m “my version is tagName” (附注标签)</p>
</li>
<li><p>git tag [tagName] （轻量标签）</p>
</li>
<li><p>追加标签</p>
<blockquote>
<p>对过去的提交打标签，利用git log查看提交历史</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>  $ git log --pretty=oneline
  0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
  ……
  9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
  ……
  964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo        </code></pre>
<blockquote>
<p>假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）</p>
</blockquote>
<ul>
<li>git tag -a v1.2 9fceb02 或 git tag -a v1.2 9fceb02d0ae598e95dc970b74767f19372d61af8</li>
</ul>
</li>
</ul>
</li>
<li><p>查看tag详细信息</p>
<blockquote>
<p>对于附注标签：显示打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息</p>
</blockquote>
<blockquote>
<p>对于轻量标签：只会显示出提交信息</p>
</blockquote>
<ul>
<li>git show [tagName]</li>
</ul>
</li>
<li><p>将Tag同步到远程服务器</p>
<blockquote>
<p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上</p>
</blockquote>
<ul>
<li>git push origin [tagName] （推送单个分支tag）</li>
<li>git push origin –tags (推送本地所有tag)</li>
</ul>
</li>
<li><p>切换到某个标签</p>
<blockquote>
<p>查看某个标签所指向的文件版本，可以直接切换到某个tag去</p>
</blockquote>
<blockquote>
<p>这个时候不位于任何分支，处于游离状态(detached HEAD),这个状态有些不好的副作用：</p>
</blockquote>
<pre><code>  此状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的commitID才能访问。 
  因此，如果你需要进行更改，比如你要修复旧版本中的错误，可以考虑基于这个tag创建一个分支</code></pre>
<ul>
<li>git checkout [tagName]</li>
<li>git checkout -b [newTagName] [tagName] （基于原Tag新建分支）</li>
</ul>
</li>
<li><p>删除标签</p>
<ul>
<li>git tag -d [tagName] （本地标签删除）</li>
<li>git push origin :refs/tags/[tagName] 或 git push origin –delete [tagName] (远端标签删除)</li>
</ul>
</li>
</ul>
<h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><ol>
<li><p>相关命令介绍</p>
<ol>
<li>git reset 将HEAD指针指到指定提交(commitID)，主要有以下三个操作选项：</li>
</ol>
<ul>
<li>git reset –soft [commitID]<blockquote>
<p>将HEAD引用指向给定提交。索引（暂存区）和工作区的内容是不变的</p>
</blockquote>
</li>
<li>git reset –mixed(默认) [commitID]<blockquote>
<p>HEAD引用指向给定提交，并且索引（暂存区）内容也跟着改变，工作区内容不变。这个命令会将索引（暂存区）变成你刚刚暂存该提交全部变化时的状态</p>
</blockquote>
</li>
<li>git reset –hard [commitID]<blockquote>
<p>HEAD引用指向给定提交，索引（暂存区）内容和工作区内容都会变给定提交时的状态。也就是在给定提交后所修改的内容都会丢失(新文件会被删除，不在工作区中的文件恢复，未清除回收站的前提)</p>
</blockquote>
</li>
</ul>
<p> <em>以表格列出各参数是否产生影响：</em></p>
<p> 选项|HEAD|暂存区|工作区<br> :–:|:–:|:–:<br> –soft|是|否|否<br> –mixed|是|是|否<br> –hard|是|是|是</p>
<ol start="2">
<li>git revert 放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</li>
</ol>
<p> <em>注意：reset与revert的区别</em></p>
<p> |reset|revert<br> :–:|:–:|:–:<br> 作用|版本回退到某一版本/提交|撤销某一个版本/提交<br> 影响|对本地的版本产生影响，push后不对远程分支产生影响(如果回退的版本小于远程分支版本，通常会提示先将本地版本内容更新至与远程版本一致)|对本地的版本产生影响并新增一条记录，push后会对远程分支产生影响<br> 示例|1-&gt;2-&gt;3-&gt;4-&gt;5,“git reset [版本3的commitID]”，这条命令会把版本3的修改和记录都撤销掉，变为1-&gt;2-&gt;3|1-&gt;2-&gt;3-&gt;4-&gt;5,“git revert [版本3的commitID]”，这条命令会把版本3的修改撤销掉，但是记录不会删除，并且新增一条revert记录，变为1-&gt;2-&gt;4-&gt;5</p>
<ol start="3">
<li><p>git status  查看文件、文件夹在工作区、暂存区的状态，有以下三种状态：</p>
<blockquote>
<p><strong>Changes to be committed</strong>:表示已经从工作区add到暂存区的file（文件或文件夹），可以通过 git reset filename命令将该file从暂存区移出</p>
</blockquote>
<blockquote>
<p><strong>Changes not staged for commit</strong>:表示工作区，暂存区都存在的file（文件或文件夹）。</p>
</blockquote>
<blockquote>
<p><strong>Untracked files</strong>:表示只在工作区有的file（文件或文件夹），也就是在暂时区没有该file</p>
</blockquote>
</li>
<li><p>git log  查看提交历史</p>
</li>
</ol>
<ul>
<li><p>git log</p>
<blockquote>
<p>无参数，git log 会按提交时间列出所有的更新，最近的更新排在最上面</p>
</blockquote>
</li>
<li><p>git log -p</p>
<blockquote>
<p>代码审查-展开内容差异</p>
</blockquote>
<blockquote>
<p>例：展开显示每次提交的内容差异, 用 -2 则仅显示最近的两次更新<br><strong>git log -p -2</strong></p>
</blockquote>
</li>
<li><p>git log –stat</p>
<blockquote>
<p>仅显示简要的增改行数统计</p>
</blockquote>
</li>
<li><p>git log –pretty</p>
<blockquote>
<p>指定使用完全不同于默认格式的方式展示提交历史,–pretty=oneline/short/full/fuller/…… 此处四种简单模式</p>
</blockquote>
<blockquote>
<p>还有定制格式，此处不详述，可自行查看<a target="_blank" rel="noopener" href="https://www.git-scm.com/docs/git-log" title="git-log">https://www.git-scm.com/docs/git-log</a></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>使用场景</p>
<ul>
<li><p>场景一：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件</p>
<blockquote>
</blockquote>
<p>  git add .  //将工作区的所有文件添加到暂存区<br>  git status //查看文件状态<br>  git reset [fileName]  //将指定文件名的文件从暂存区撤出</p>
</li>
<li><p>场景二：刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作</p>
<blockquote>
</blockquote>
<p>  git add ff.txt<br>  git commit -m “Add ff”<br>  //撤销上一次commit<br>  git reset –soft [HEAD^/上一次commitID] //ff.txt还保留在暂存区<br>  git reset [HEAD^/上一次commitID] //ff.txt不在暂存区，只有工作区还有<br>  git reset –hard [HEAD^/上一次commitID] //暂存区、工作区都没有保留ff.txt了</p>
</li>
<li><p>场景三：刚push的代码有问题，需要进行这次提交的回滚 【<em>对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员</em>】</p>
<blockquote>
</blockquote>
<p>  (以master分支为例)<br>  方法一：使用revert<br>  git revert HEAD<br>  git push origin master<br>  方法二：使用reset<br>  git reset –hard HEAD^<br>  git push origin master -f    </p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/21/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" data-id="ckgipo2vn0000lgt4cmtud8w5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/08/11/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/21/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/08/11/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>